import { useEffect, useState } from "react";

// Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò
const formatDate = (iso) => {
  const date = new Date(iso);
  const dayNames = ["Ïùº", "Ïõî", "Ìôî", "Ïàò", "Î™©", "Í∏à", "ÌÜ†"];
  const dayName = dayNames[date.getDay()];
  return `${date.getMonth() + 1}/${date.getDate()}(${dayName})`;
};

const getWeatherEmoji = (weatherCode) => {
  if (!weatherCode) return "üå´Ô∏è";

  const code = parseInt(weatherCode);

  if (code === 0) return "‚òÄÔ∏è";
  if (code === 1) return "üå§Ô∏è";
  if (code === 2) return "‚õÖ";
  if (code === 3) return "üå•Ô∏è";
  if (code >= 45 && code <= 48) return "üå´Ô∏è";
  if (code >= 51 && code <= 55) return "üåßÔ∏è";
  if (code >= 61 && code <= 65) return "üå¶Ô∏è";
  if (code >= 66 && code <= 68) return "‚ùÑÔ∏è";
  if (code >= 71 && code <= 75) return "üå®Ô∏è";
  if (code >= 80 && code <= 82) return "üåßÔ∏è";
  if (code >= 85 && code <= 86) return "üå®Ô∏è";
  if (code >= 95 && code <= 99) return "‚õàÔ∏è";

  return "üå´Ô∏è"; // Í∏∞Î≥∏Í∞í
}

// API Í¥ÄÎ†® ÏÉÅÏàò
const GEOCODING_API_URL = "https://geocoding-api.open-meteo.com/v1/search";
const WEATHER_API_URL = "https://api.open-meteo.com/v1/forecast";
const MIN_CITY_LENGTH = 3;
const AUTOCOMPLETE_DELAY = 300;

// ÏÑúÏö∏ Ï¢åÌëú (Ìè¥Î∞±Ïö©)
const SEOUL_COORDS = {
  lat: 37.5665,
  lon: 126.9780,
  label: "Seoul",
  country: "KR",
};

export default function App() {
  // ÏûÖÎ†• ÏÉÅÌÉú
  const [city, setCity] = useState("");
  const [target, setTarget] = useState("");
  
  // ÏßÄÏò§ÏΩîÎî© ÏÉÅÌÉú
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [coords, setCoords] = useState(null);
  
  // ÎÇ†Ïî® ÏÉÅÌÉú
  const [weatherLoading, setWeatherLoading] = useState(false);
  const [weatherError, setWeatherError] = useState("");
  const [currentWeather, setCurrentWeather] = useState(null);
  const [dailyForecast, setDailyForecast] = useState([]);
  
  // ÏûêÎèôÏôÑÏÑ± ÏÉÅÌÉú
  const [candidates, setCandidates] = useState([]);
  const [isManualSelection, setIsManualSelection] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);

  // ÌõÑÎ≥¥ ÏÑ†ÌÉù Ìï∏Îì§Îü¨
  const handleCandidateSelect = (candidate) => {
    setError("");
    setIsManualSelection(true);
    setCoords(candidate);
    setTarget(candidate.label);
    setCandidates([]);
    setSelectedIndex(-1);
  };

  // ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Ìï∏Îì§Îü¨
  const handleKeyDown = (e) => {
    if (candidates.length == 0 ) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev =>
          prev < candidates.length - 1 ? prev + 1 : 0
        );
        break;

      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev =>
          prev > 0 ? prev - 1 : candidates.length - 1
        );
        break;

      case 'Enter':
        e.preventDefault();
        if (selectedIndex >= 0 && candidates[selectedIndex]) {
          handleCandidateSelect(candidates[selectedIndex]);
        } else {
          const trimmedCity = city.trim();
          if (trimmedCity.length >= MIN_CITY_LENGTH) {
            setTarget(trimmedCity);
            setCandidates([]);
            setSelectedIndex(-1);
          }
        }
        break;

      case 'Escape':
        setCandidates([]);
        setSelectedIndex(-1);
        break;
    }
  };
  // Ìèº Ï†úÏ∂ú Ìï∏Îì§Îü¨
  const handleSubmit = (e) => {
    e.preventDefault();
    const trimmedCity = city.trim();
    
    if (trimmedCity.length < MIN_CITY_LENGTH) {
      setError("ÎèÑÏãúÎ™ÖÏùÄ 3Í∏ÄÏûê Ïù¥ÏÉÅ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.");
      return;
    }
    
    setTarget(trimmedCity);
  };

  // ÏßÄÏò§ÏΩîÎî© API Ìò∏Ï∂ú
  const fetchGeocoding = async (cityName) => {
    const url = new URL(GEOCODING_API_URL);
    url.searchParams.set("name", cityName);
    url.searchParams.set("count", "5");
    url.searchParams.set("language", "ko");
    url.searchParams.set("format", "json");

    const response = await fetch(url.toString());
    if (!response.ok) throw new Error("ÏßÄÏò§ÏΩîÎî© ÏöîÏ≤≠ Ïã§Ìå®");
    
    return response.json();
  };

  // ÎÇ†Ïî® API Ìò∏Ï∂ú
  const fetchWeather = async (coordinates) => {
    const url = new URL(WEATHER_API_URL);
    url.searchParams.set("latitude", coordinates.lat);
    url.searchParams.set("longitude", coordinates.lon);
    url.searchParams.set("timezone", "auto");
    url.searchParams.set("forecast_days", "14");
    url.searchParams.set(
      "current",
      "temperature_2m,apparent_temperature,relative_humidity_2m,wind_speed_10m,weather_code"
    );
    url.searchParams.set(
      "daily",
      "temperature_2m_max,temperature_2m_min,weather_code"
    );

    const response = await fetch(url.toString());
    if (!response.ok) throw new Error("ÏòàÎ≥¥ API Ïã§Ìå®");
    
    return response.json();
  };

  // ÏßÄÏò§ÏΩîÎî© Ìö®Í≥º
  useEffect(() => {
    if (!target) return;

    let isCancelled = false;

    const performGeocoding = async () => {
      // ÏàòÎèô ÏÑ†ÌÉù ÏßÅÌõÑÏóî ÏßÄÏò§ÏΩîÎî© Ïä§ÌÇµ
      if (isManualSelection) {
        setIsManualSelection(false);
        return;
      }

      setLoading(true);
      setError("");
      setCoords(null);

      try {
        const data = await fetchGeocoding(target);
        
        const locations = (data.results || []).map(result => ({
          lat: result.latitude,
          lon: result.longitude,
          label: result.name,
          country: result.country || ""
        }));

        if (!locations.length) {
          throw new Error("Ìï¥Îãπ ÎèÑÏãúÎ•º Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§.");
        }

        // ÏûÖÎ†•Í∞íÍ≥º Í∞ÄÏû• Ïú†ÏÇ¨Ìïú Í≤∞Í≥º ÏÑ†ÌÉù
        const query = target.toLowerCase();
        const exactMatch = locations.filter(location => 
          location.label.toLowerCase().startsWith(query)
        );
        const selectedLocation = exactMatch[0] || locations[0];

        if (!isCancelled) {
          setCoords(selectedLocation);
          setError("");
        }
      } catch (err) {
        if (!isCancelled) {
          setError(err.message || "ÏßÄÏò§ÏΩîÎî© Ïã§Ìå®: ÏûÑÏãúÎ°ú ÏÑúÏö∏ Ï¢åÌëú ÏÇ¨Ïö©");
          setCoords(SEOUL_COORDS);
        }
      } finally {
        if (!isCancelled) {
          setLoading(false);
        }
      }
    };

    performGeocoding();
    return () => { isCancelled = true; };
  }, [target, isManualSelection]);

  // ÎÇ†Ïî® Ï°∞Ìöå Ìö®Í≥º
  useEffect(() => {
    if (!coords) return;

    let isCancelled = false;

    const fetchWeatherData = async () => {
      setWeatherLoading(true);
      setWeatherError("");
      setCurrentWeather(null);
      setDailyForecast([]);

      try {
        const weatherData = await fetchWeather(coords);

        if (!isCancelled) {
          // ÌòÑÏû¨ ÎÇ†Ïî® ÏÑ§Ï†ï
          setCurrentWeather({
            temp: weatherData.current?.temperature_2m,
            feels: weatherData.current?.apparent_temperature,
            humidity: weatherData.current?.relative_humidity_2m,
            wind: weatherData.current?.wind_speed_10m,
            code: weatherData.current?.weather_code,
          });

          // ÏùºÍ∏∞ ÏòàÎ≥¥ ÏÑ§Ï†ï
          const forecast = (weatherData.daily?.time || []).map((date, index) => ({
            date,
            label: formatDate(date),
            tempMin: weatherData.daily?.temperature_2m_min?.[index],
            tempMax: weatherData.daily?.temperature_2m_max?.[index],
            code: weatherData.daily?.weather_code?.[index],
          }));

          setDailyForecast(forecast);
        }
      } catch (err) {
        if (!isCancelled) {
          setWeatherError(err.message || "ÏòàÎ≥¥Î•º Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.");
        }
      } finally {
        if (!isCancelled) {
          setWeatherLoading(false);
        }
      }
    };

    fetchWeatherData();
    return () => { isCancelled = true; };
  }, [coords]);

  // ÏûêÎèôÏôÑÏÑ± Ìö®Í≥º
  useEffect(() => {
    const trimmedCity = city.trim();
    
    if (trimmedCity.length < MIN_CITY_LENGTH) {
      setCandidates([]);
      return;
    }

    const timeoutId = setTimeout(async () => {
      try {
        const data = await fetchGeocoding(trimmedCity);
        
        const candidateList = (data.results || []).map(result => ({
          lat: result.latitude,
          lon: result.longitude,
          label: result.name,
          country: result.country || "",
          code: result.country_code || "",
          detail: [result.admin1, result.admin2, result.country]
            .filter(Boolean)
            .join(" / "),
        }));
        
        setCandidates(candidateList);
      } catch (err) {
        console.error("ÏûêÎèôÏôÑÏÑ± Ïò§Î•ò:", err);
        setCandidates([]);
        setSelectedIndex(-1);
      }
    }, AUTOCOMPLETE_DELAY);

    return () => clearTimeout(timeoutId);
  }, [city]);

  // Ïä§ÌÉÄÏùº Í∞ùÏ≤¥
  const styles = {
    container: { 
      fontFamily: "ÎÇòÎàîÍ≥†Îîï, sans-serif",
      maxWidth: "720px",
      margin: "0 3px",
      padding: "20px 4px !important",
      paddingLeft: "4px !important",
      paddingRight: "4px !important",
    },
    inputContainer: { 
      position: "relative",
      display: "flex",
      gap: "8px",
      alignItems: "center"      
    },

    input: { 
      flex: 1,
      padding: "8px",
      fontsize: "14px !important",
      border : "2px solid #4462858a",
      height: "30px",
    },
      // width: "100%", padding: "8px", fontSize: "14px" },
    button: { 
      // marginTop: "6px", 
      whiteSpace: "nowrap",
      flexShrink: 0,
      padding: "4px 8px",
      backgroundColor: "#f8f9fa",
      color: "rgba(73, 69, 69, 0.87)",
      border: "2px solid #4462858a",
      borderRadius: "12px",
      cursor: "pointer",
      fontSize: "14px",
      height: "30px",
    },
    autocompleteContainer: {
      position: "absolute",
      left: 0,
      right: 0,
      top: "100%",
      marginTop: "6px",
      border: "2px solid #4462858a",
      borderRadius: "8px",
      padding: "6px",
      background: "#f8f9fa",
      maxHeight: "40vh",
      overflowY: "auto",
      zIndex: 10,
    },
    candidateButton: {
      display: "block",
      width: "100%",
      textAlign: "left",
      padding: "6px 8px",
      border: "2px solid #4462858a",
      borderRadius: "6px",
      background: "transparent",
      cursor: "pointer",
      marginBottom: "6px",
      transition: "background-color 0.2s ease",
    },
    candidateButtonSelected: {
      backgroundColor: "#dfeef5",
      borderColor: "#4462858a",
    },
    infoBox: {
      marginTop: "6px",
      padding: "2px 14px",
      fontSize: "14px",
      border: "2px solid #4462858a",
      borderRadius: "12px",
      backgroundColor: "#f8f9fa"
    },
    forecastBox: {
      marginTop: "6px",
      padding: "2px 14px",
      fontSize: "14px",
      border: "2px solid #4462858a",
      borderRadius: "12px",
      backgroundColor: "#f8f9fa",
      maxHeight: "260px", // ÏµúÎåÄ ÎÜíÏù¥ ÏÑ§Ï†ï
      overflowY: "auto",   // ÏÑ∏Î°ú Ïä§ÌÅ¨Î°§ ÌôúÏÑ±Ìôî
    },
    errorText: { 
      color: "crimson",
      margin: "4px 0"},
    statusText: { 
      margin: "4px 0",
      fontSize: "14px"
     }
  };

  return (
    <div style={styles.container}>
      <h1 style={{ textAlign: "center" }}>ÎÇ†Ïî®ÎÇ†Ïî®</h1>

      {/* ÏûÖÎ†• Ìèº */}
      <form onSubmit={handleSubmit} style={{ marginTop: "14px"}}>
        <div style={styles.inputContainer}>
          <input
            style={styles.input}
            placeholder="ÎèÑÏãúÎ™ÖÏùÑ ÏûÖÎ†• (Ïòà: Seoul, Tokyo, Paris)"
            value={city}
            onChange={(e) => setCity(e.target.value)}
            onKeyDown={handleKeyDown}
          />
          <button type="submit" style={styles.button}>
            Ï°∞Ìöå
          </button>


          {/* ÏûêÎèôÏôÑÏÑ± Î™©Î°ù */}
          {candidates.length > 0 && (
            <div style={styles.autocompleteContainer}>
              {candidates.map((candidate, index) => (
                <button
                  key={`${candidate.label}-${candidate.lat}-${candidate.lon}`}
                  style={{
                    ...styles.candidateButton,
                    ...(index === selectedIndex ? styles.candidateButtonSelected : {})
                  }}
                  onClick={() => handleCandidateSelect(candidate)}
                  type="button"
                >
                  <strong>{candidate.label && <span style={{ color: "#727272" }}>{candidate.label}</span>}</strong>
                  
                  {candidate.country && <span style={{ color: "#727272" }}>, {candidate.country}</span>}
                  
                  {candidate.code && <span style={{ color: "#727272" }}> ({candidate.code})</span>}
                  
                  {candidate.detail && (
                    <span style={{ color: "#727272" }}> ‚Äî {candidate.detail}</span>
                  )}
                </button>
              ))}
            </div>
          )}
        </div>
      </form>

      {/* ÏÉÅÌÉú ÎØ∏Î¶¨Î≥¥Í∏∞ */}
      <div style={{ marginTop: "6px" }}>
        <p style={styles.statusText}>
          ÏûÖÎ†• Ï§ë: <strong>{city || "ÏóÜÏùå"}</strong>
        </p>
        <p style={styles.statusText}>
          Ï°∞Ìöå ÎåÄÏÉÅ: <strong>{target || "ÎØ∏Ï†ï"}</strong>
        </p>
      </div>

      {/* ÏßÄÏò§ÏΩîÎî© Í≤∞Í≥º */}
      <div style={{ marginTop: "6px" }}>
        {loading && <p style={{ fontSize: "14px", margin: "6px 0" }}>ÏúÑÏπò Ï∞æÎäî Ï§ë...</p>}
        {error && <p style={styles.errorText}>{error}</p>}
        {coords && !loading && (
          <div style={styles.infoBox}>
            <p style={{ margin: "4px 0" }}>
              <strong>ÎèÑÏãú:</strong> {coords.label}
              {coords.country && `, ${coords.country}`}
            </p>
            <p style={{ margin: "4px 0" }}><strong>ÏúÑÎèÑ:</strong> {coords.lat}</p>
            <p style={{ margin: "4px 0" }}><strong>Í≤ΩÎèÑ:</strong> {coords.lon}</p>
          </div>
        )}
      </div>

      {/* ÎÇ†Ïî® Ï†ïÎ≥¥ */}
      <div style={{ marginTop: "4px" }}>
        {weatherLoading && <p style={{ fontSize: "14px", margin: "6px 0"}}>ÎÇ†Ïî® Î∂àÎü¨Ïò§Îäî Ï§ë...</p>}
        {weatherError && <p style={styles.errorText}>{weatherError}</p>}

        {/* ÌòÑÏû¨ ÎÇ†Ïî® */}
        {currentWeather && !weatherLoading && !weatherError && (
          <div style={styles.infoBox}>
            <h3 style={{ margin: "6px 0 6px 0", fontSize: "14px" }}>{getWeatherEmoji(currentWeather.code)} ÌòÑÏû¨ ÎÇ†Ïî®</h3>
            <p style={{ margin: "4px 0" }}>
              <strong>Í∏∞Ïò®:</strong> {' '}
              {currentWeather.temp != null 
                ? `${Math.round(currentWeather.temp)}¬∞C` 
                : "-"}
            </p>
            <p style={{ margin: "4px 0" }}>
              <strong>Ï≤¥Í∞ê:</strong> {' '}
              {currentWeather.feels != null 
                ? `${Math.round(currentWeather.feels)}¬∞C` 
                : "-"} {' '}
              | <strong>ÏäµÎèÑ:</strong> {' '}
              {currentWeather.humidity != null 
                ? `${currentWeather.humidity}%` 
                : "-"} {' '}
              | <strong>Î∞îÎûå:</strong> {' '}
              {currentWeather.wind != null 
                ? `${currentWeather.wind} m/s` 
                : "-"}
            </p>
          </div>
        )}

        {/* 5Ïùº ÏòàÎ≥¥ */}
        {dailyForecast.length > 0 && !weatherLoading && !weatherError && (
          <div style={styles.forecastBox}>
            <h3 style={{ margin: "6px 0 6px 0", fontSize: "14px" }}>ÏùºÍ∏∞ ÏòàÎ≥¥</h3>
            <ul style={{ paddingLeft: "10px", margin: "0"  }}>
              {dailyForecast.map((day) => (
                <li key={day.date} style={{ marginBottom: "2px", fontSize: "14px"}}>
                  {getWeatherEmoji(day.code)}
                  <strong>{day.label}</strong> - {' '}
                  {Math.round(day.tempMin)}¬∞ / {Math.round(day.tempMax)}¬∞
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </div>
  );
}